
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2011 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D's Contract Programming vs C++'s - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="/js/hyphenate_selectively.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
	var links = document.getElementById("navigation").getElementsByTagName("a");
	for (var i = 0; i < links.length; i++)
	{
		var url = "/" + links[i].getAttribute("href");
		if (window.location.href.match(url + "\x24") == url)
		{
			var cls = links[i].getAttribute("class");
			links[i].setAttribute("class", cls ? cls + " active" : "active");
			break;
		}
	}
}
</script>
</head>

<body onLoad='bodyLoad()' class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="/images/search-button.gif" />
			<input type="hidden" id="domains" name="domains" value="d-programming-language.org" />
			<input type="hidden" id="sourceid" name="sourceid" value="google-search" />
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="d-programming-language.org">Entire D 2.0 Site</option>
					<option value="d-programming-language.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language 2.0</a>
	</div>
</div>

<!-- Generated by Ddoc from cppdbc.dd -->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D 2.0 Home</a></h2>
<ul><li><a href="overview.html" title="D language overview">Overview</a>

    <div class="navblock">
<ul><li><a href="wc.html" title="wc - the wordcount program">Example: wc</a></li>
	<li><a href="warnings.html" title="Explanation of D compiler generated warning messages">Warnings</a></li>
	<li><a href="builtin.html">   Rationale for Builtins</a></li>
	<li><a href="ctod.html">      Converting C to D</a></li>
	<li><a href="cpptod.html">    Converting C++ to D</a></li>
	<li><a href="pretod.html">The C Preprocessor vs D</a></li>
	<li><a href="template-comparison.html">D templates compared</a></li>
	<li><a href="cppstrings.html">D strings vs C++ std::string</a></li>
	<li><a href="cppcomplex.html">D complex vs C++ std::complex</a></li>
	<li><a href="cppdbc.html">    D Contract Programming vs C++</a></li>
	<li><a href="lisp-java-d.html">Lisp vs. Java... D?</a></li>
	<li><a href="cpp0x.html">D and C++0x</a></li>
</ul>
</div></li>
	<li><a href="comparison.html" title="D feature list">Features</a></li>
	<li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>
	<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
	<li><a href="appendices.html">Appendices</a></li>
	<li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgements</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Documentation</h2>
<ul><li><a href="language-reference.html">Language Reference</a></li>
	<li><a href="phobos/index.html">Library Reference</a></li>
	<li><a href="howtos.html" title="Helps for using D">Howtos</a></li>
	<li><a href="articles.html">Articles</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Community</h2>
<ul><li><a href="http://www.digitalmars.com/NewsGroup.html" title="User forums">Forums</a></li>
	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?FrontPage" title="Wiki for the D Programming Language">Wiki</a></li>
	<li><a href="http://www.dsource.org/" title="D projects and libraries at dsource.org">Projects &amp; Libraries</a></li>
	<li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
	<li><a href="http://www.digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
	
	
</ul>
    </div>
  
<div id="translate" class="tool"><script type="text/javascript">document.write("Translate this page:")</script>
	<div id="google_translate_element"></div><script type="text/javascript">
	function googleTranslateElementInit() {
	  new google.translate.TranslateElement({
	    pageLanguage: 'en',
	    autoDisplay: false,
	    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
	  }, 'google_translate_element');
	}
	</script><script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>
</div>
<div id="content">
  
<div id="tools">
	<span id="lastupdate">Last update Mon May 16 20:47:27 2011
</span>
	<span id="wiki"><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/CppDbc">Comment on this page</a></span>
</div>
  <h1>          D's Contract Programming vs C++'s</h1>
  	Many people have written me saying that D's Contract Programming
	(DbC) does not add anything that C++ does not already support.
	They go on to illustrate their point with a technique for doing DbC in
	C++.
	<p>

	It makes sense to review what DbC is, how it is done in D,
	and stack that up with what each of the various C++ DbC techniques
	can do.
	<p>

	Digital Mars C++ adds
	<a href="../ctg/contract.html">extensions to C++</a>
	to support DbC, but they are not covered here because they are not
	part of standard C++ and are not supported by any other C++ compiler.

<h2>Contract Programming in D</h2>

	This is more fully documented in the D
	<a href="dbc.html">Contract Programming</a> document.
	To sum up, DbC in D has the following characteristics:

	<ol>
	<li>The <i>assert</i> is the basic contract.
	</li>

	<li>When an assert contract fails, it throws an exception.
	Such exceptions can be caught and handled, or allowed to
	terminate the program.
	</li>

	<li>Classes can have <i>class invariants</i> which are
	checked upon entry and exit of each public class member function,
	the exit of each constructor, and the entry of the destructor.
	</li>

	<li>Assert contracts on object references check the class
	invariant for that object.
	</li>

	<li>Class invariants are inherited, that means that a derived
	class invariant will implicitly call the base class invariant.
	</li>

	<li>Functions can have <i>preconditions</i> and <i>postconditions</i>.
	</li>

	<li>For member functions in a class inheritance hierarchy, the
	precondition of a derived class function are OR'd together
	with the preconditions of all the functions it overrides.
	The postconditions are AND'd together.
	</li>

	<li>By throwing a compiler switch, DbC code can be enabled
	or can be withdrawn from the compiled code.
	</li>

	<li>Code works semantically the same with or without DbC
	checking enabled.
	</li>

	</ol>

<h2>Contract Programming in C++</h2>

<h3>The <tt>assert</tt> Macro</h3>

	C++ does have the basic <tt>assert</tt> macro, which tests its argument
	and if it fails, aborts the program. <tt>assert</tt> can be turned
	on and off with the <tt>NDEBUG</tt> macro.
	<p>

	<tt>assert</tt> does not know anything about class invariants,
	and does not throw an exception when it fails. It just aborts
	the program after writing a message. <tt>assert</tt> relies on
	a macro text preprocessor to work.
	<p>

	<tt>assert</tt> is where explicit support for DbC in Standard C++
	begins and ends.

<h3>Class Invariants</h3>

	Consider a class invariant in D:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A
{
    <b><span class="d_keyword">invariant</span></b>() { ...contracts... }

    <span class="d_keyword">this</span>() { ... }	<span class="d_comment">// constructor
</span>    ~<span class="d_keyword">this</span>() { ... }	<span class="d_comment">// destructor
</span>
    <span class="d_keyword">void</span> foo() { ... }	<span class="d_comment">// public member function
</span>}

<span class="d_keyword">class</span> B : A
{
    <b><span class="d_keyword">invariant</span></b>() { ...contracts... }
    ...
}
</span></pre>

	To accomplish the equivalent in C++ (thanks to Bob Bell for providing
	this):

<pre class="ccode"><span class="notranslate">template<typename T>
inline void check_invariant(T&amp; iX)
{
#ifdef DBC
    iX.invariant();
#endif
}

// A.h:

class A {
    public:
#ifdef DBG
       virtual void invariant() { ...contracts... }
#endif
       void foo();
};

// A.cpp:

void A::foo()
{
    check_invariant(*this);
    ...
    check_invariant(*this);
}

// B.h:

#include "A.h"

class B : public A {
    public:
#ifdef DBG
	virtual void invariant()
	{   ...contracts...
	   A::invariant();
	}
#endif
       void bar();
};

// B.cpp:

void B::barG()
{
    check_invariant(*this);
    ...
    check_invariant(*this);
}
</span></pre>

	There's an additional complication with <tt>A::foo()</tt>. Upon every
	normal exit from the function, the <tt>invariant()</tt> should be
	called.
	This means that code that looks like:

<pre class="ccode"><span class="notranslate">int A::foo()
{
    ...
    if (...)
	return bar();
    return 3;
}
</span></pre>

	would need to be written as:

<pre class="ccode"><span class="notranslate">int A::foo()
{
    int result;
    check_invariant(*this);
    ...
    if (...)
    {
	result = bar();
	check_invariant(*this);
	return result;
    }
    check_invariant(*this);
    return 3;
}
</span></pre>

	Or recode the function so it has a single exit point.
	One possibility to mitigate this is to use RAII techniques:

<pre class="ccode"><span class="notranslate">int A::foo()
{
#if DBC
    struct Sentry {
       Sentry(A&amp; iA) : mA(iA) { check_invariants(iA); }
       ~Sentry() { check_invariants(mA); }
       A&amp; mA;
    } sentry(*this);
#endif
    ...
    if (...)
	return bar();
    return 3;
}
</span></pre>

	The #if DBC is still there because some compilers may not
	optimize the whole thing away if check_invariants compiles to nothing.

<h2>Preconditions and Postconditions</h2>

	Consider the following in D:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo()
    <span class="d_keyword">in</span> { ...preconditions... }
    <span class="d_keyword">out</span> { ...postconditions... }
    <span class="d_keyword">body</span>
    {
	...implementation...
    }
</span></pre>

	This is nicely handled in C++ with the nested Sentry struct:

<pre class="ccode"><span class="notranslate">void foo()
{
    struct Sentry
    {   Sentry() { ...preconditions... }
	~Sentry() { ...postconditions... }
    } sentry;
    ...implementation...
}
</span></pre>

	If the preconditions and postconditions consist of nothing
	more than <tt>assert</tt> macros, the whole doesn't need to
	be wrapped in a <tt>#ifdef</tt> pair, since a good C++ compiler will
	optimize the whole thing away if the <tt>assert</tt>s are turned off.
	<p>

	But suppose <tt>foo()</tt> sorts an array, and the postcondition needs
	to walk the array and verify that it really is sorted. Now
	the shebang needs to be wrapped in <tt>#ifdef</tt>:

<pre class="ccode"><span class="notranslate">void foo()
{
#ifdef DBC
    struct Sentry
    {   Sentry() { ...preconditions... }
	~Sentry() { ...postconditions... }
    } sentry;
#endif
    ...implementation...
}
</span></pre>

	(One can make use of the C++ rule that templates are only
	instantiated when used can be used to avoid the <tt>#ifdef</tt>, by
	putting the conditions into a template function referenced
	by the <tt>assert</tt>.)
	<p>

	Let's add a return value to <tt>foo()</tt> that needs to be checked in
	the postconditions. In D:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo()
    <span class="d_keyword">in</span> { ...preconditions... }
    <span class="d_keyword">out</span> (result) { ...postconditions... }
    <span class="d_keyword">body</span>
    {
	...implementation...
	<span class="d_keyword">if</span> (...)
	    <span class="d_keyword">return</span> bar();
	<span class="d_keyword">return</span> 3;
    }
</span></pre>

	In C++:

<pre class="ccode"><span class="notranslate">int foo()
{
#ifdef DBC
    struct Sentry
    {   int result;
	Sentry() { ...preconditions... }
	~Sentry() { ...postconditions... }
    } sentry;
#endif
    ...implementation...
    if (...)
    {   int i = bar();
#ifdef DBC
	sentry.result = i;
#endif
	return i;
    }
#ifdef DBC
    sentry.result = 3;
#endif
    return 3;
}
</span></pre>

	Now add a couple parameters to <tt>foo()</tt>. In D:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
    <span class="d_keyword">in</span> { ...preconditions... }
    <span class="d_keyword">out</span> (result) { ...postconditions... }
    <span class="d_keyword">body</span>
    {
	...implementation...
	<span class="d_keyword">if</span> (...)
	    <span class="d_keyword">return</span> bar();
	<span class="d_keyword">return</span> 3;
    }
</span></pre>

	In C++:

<pre class="ccode"><span class="notranslate">int foo(int a, int b)
{
#ifdef DBC
    struct Sentry
    {   int a, b;
	int result;
	Sentry(int a, int b)
	{   this-&gt;a = a;
	    this-&gt;b = b;
	    ...preconditions...
	}
	~Sentry() { ...postconditions... }
    } sentry(a,b);
#endif
    ...implementation...
	if (...)
	{   int i = bar();
#ifdef DBC
	    sentry.result = i;
#endif
	    return i;
	}
#ifdef DBC
	sentry.result = 3;
#endif
	return 3;
}
</span></pre>

<h2>Preconditions and Postconditions for Member Functions</h2>

	Consider the use of preconditions and postconditions for a
	polymorphic function in D:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> foo()
	<span class="d_keyword">in</span> { ...Apreconditions... }
	<span class="d_keyword">out</span> { ...Apostconditions... }
	<span class="d_keyword">body</span>
	{
	    ...implementation...
	}
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> foo()
	<span class="d_keyword">in</span> { ...Bpreconditions... }
	<span class="d_keyword">out</span> { ...Bpostconditions... }
	<span class="d_keyword">body</span>
	{
	    ...implementation...
	}
}
</span></pre>

	The semantics for a call to <tt>B.foo()</tt> are:

	<ul>	<li>Either Apreconditions or Bpreconditions must be satisfied.</li>
	<li>Both Apostconditions and Bpostconditions must be satisfied.</li>
	</ul>

	Let's get this to work in C++:

<pre class="ccode"><span class="notranslate">class A
{
protected:
    #if DBC
    int foo_preconditions() { ...Apreconditions... }
    void foo_postconditions() { ...Apostconditions... }
    #else
    int foo_preconditions() { return 1; }
    void foo_postconditions() { }
    #endif

    void foo_internal()
    {
	...implementation...
    }

public:
    virtual void foo()
    {
	foo_preconditions();
	foo_internal();
	foo_postconditions();
    }
};

class B : A
{
protected:
    #if DBC
    int foo_preconditions() { ...Bpreconditions... }
    void foo_postconditions() { ...Bpostconditions... }
    #else
    int foo_preconditions() { return 1; }
    void foo_postconditions() { }
    #endif

    void foo_internal()
    {
	...implementation...
    }

public:
    virtual void foo()
    {
	assert(foo_preconditions() || A::foo_preconditions());
	foo_internal();
	A::foo_postconditions();
	foo_postconditions();
    }
};
</span></pre>

	Something interesting has happened here. The preconditions can
	no longer be done using <tt>assert</tt>, since the results need
	to be OR'd together. I'll leave as a reader exercise adding
	in a class invariant, function return values for <tt>foo()</tt>,
	and parameters
	for <tt>foo()</tt>.

<h2>Conclusion</h2>

	These C++ techniques can work up to a point. But, aside from
	<tt>assert</tt>, they are not standardized and so will vary from
	project to project. Furthermore, they require much tedious
	adhesion to a particular convention, and add significant clutter
	to the code. Perhaps that's why it's rarely seen in practice.
	<p>

	By adding support for DbC into the language, D offers an easy
	way to use DbC and get it right. Being in the language standardizes
	the way it will be used from project to project.

<h2>References</h2>

	Chapter C.11 introduces the theory and rationale of
	Contract Programming in
	<a href="http://www.amazon.com/exec/obidos/ASIN/0136291554/classicempire">
	Object-Oriented Software Construction
	</a><br>
	Bertrand Meyer, Prentice Hall
	<p>

	Chapters 24.3.7.1 to 24.3.7.3 discuss Contract Programming in C++ in
	<a href="http://www.amazon.com/exec/obidos/ASIN/0201700735/classicempire">
	The C++ Programming Language Special Edition
	</a><br>
	Bjarne Stroustrup, Addison-Wesley
	<p>


  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>



<div id="footernav">
<a href="http://www.digitalmars.com/NewsGroup.html" title="User Forums">Forums</a> |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/CppDbc" title="Read/write comments and feedback">Comments</a> |
<a href="index.html" title="D Programming Language" class="dlink">&nbsp;D&nbsp;</a> |
<a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2011 by Digital Mars &reg;, All Rights Reserved |
Page generated by <a href="ddoc.html">Ddoc</a>.
</div>
</body>
</html>
