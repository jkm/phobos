
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2011 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D Programming Language, const,
final, invariant" />
<meta name="description" content="Comparison of const between the
D programming language, C++, and C++0x" />
<title>Final, Const, and Invariant - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="/js/hyphenate_selectively.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
	var links = document.getElementById("navigation").getElementsByTagName("a");
	for (var i = 0; i < links.length; i++)
	{
		var url = "/" + links[i].getAttribute("href");
		if (window.location.href.match(url + "\x24") == url)
		{
			var cls = links[i].getAttribute("class");
			links[i].setAttribute("class", cls ? cls + " active" : "active");
			break;
		}
	}
}
</script>
</head>

<body onLoad='bodyLoad()' class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="/images/search-button.gif" />
			<input type="hidden" id="domains" name="domains" value="d-programming-language.org" />
			<input type="hidden" id="sourceid" name="sourceid" value="google-search" />
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="d-programming-language.org">Entire D 2.0 Site</option>
					<option value="d-programming-language.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language 2.0</a>
	</div>
</div>

<!-- Generated by Ddoc from final-const-invariant.dd -->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D 2.0 Home</a></h2>
<ul><li><a href="overview.html" title="D language overview">Overview</a></li>
	<li><a href="comparison.html" title="D feature list">Features</a></li>
	<li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>
	<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
	<li><a href="appendices.html">Appendices</a></li>
	<li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgements</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Documentation</h2>
<ul><li><a href="language-reference.html">Language Reference</a></li>
	<li><a href="phobos/index.html">Library Reference</a></li>
	<li><a href="howtos.html" title="Helps for using D">Howtos</a></li>
	<li><a href="articles.html">Articles</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Community</h2>
<ul><li><a href="http://www.digitalmars.com/NewsGroup.html" title="User forums">Forums</a></li>
	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?FrontPage" title="Wiki for the D Programming Language">Wiki</a></li>
	<li><a href="http://www.dsource.org/" title="D projects and libraries at dsource.org">Projects &amp; Libraries</a></li>
	<li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
	<li><a href="http://www.digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
	
	
</ul>
    </div>
  
<div id="translate" class="tool"><script type="text/javascript">document.write("Translate this page:")</script>
	<div id="google_translate_element"></div><script type="text/javascript">
	function googleTranslateElementInit() {
	  new google.translate.TranslateElement({
	    pageLanguage: 'en',
	    autoDisplay: false,
	    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
	  }, 'google_translate_element');
	}
	</script><script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>
</div>
<div id="content">
  
<div id="tools">
	<span id="lastupdate">Last update Mon May 16 20:47:30 2011
</span>
	<span id="wiki"><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/FinalConstInvariant">Comment on this page</a></span>
</div>
  <h1>          Final, Const, and Invariant</h1>
  	<p>Being able to specify what parts of variables data can change, and under
	what conditions, can add greatly to the understandability of interfaces,
	being able to analyse code for correctness, and improve code
	generation.
	</p>

	<p>With invariant, const and final, the programmer can carefully control
	these attributes.
	</p>

<h2>Invariant Storage Class</h2>

	<p>An invariant declaration cannot change, ever, and any data
	that can be referenced through the invariant cannot ever
	change. Initializers for invariant declarations can be placed into
	ROM (Read Only Memory).
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span> <span class="d_keyword">int</span> x = 3;	<span class="d_comment">// x is set to 3
</span>	<span class="d_keyword">invariant</span> <span class="d_keyword">int</span> y;	<span class="d_comment">// y is set to int.init, which is 0
</span>	x = 4;			<span class="d_comment">// error, x is invariant
</span>	y = 5;			<span class="d_comment">// error, y is invariant
</span></pre>

	<p>The initializer for an invariant declaration must be evaluatable
	at compile time:
	</p>

<pre class="d_code2">	<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> f) { <span class="d_keyword">return</span> f * 3; }
	<span class="d_keyword">int</span> i = 5;
	<span class="d_keyword">invariant</span> <span class="d_keyword">int</span> x = 3 * 4;	<span class="d_comment">// ok, 12
</span>	<span class="d_keyword">invariant</span> <span class="d_keyword">int</span> y = i + 1;	<span class="d_comment">// error, cannot evaluate at compile time
</span>	<span class="d_keyword">invariant</span> <span class="d_keyword">int</span> z = foo(2) + 1;	<span class="d_comment">// ok, foo(2) can be evaluated at compile time, 7
</span></pre>

	<p>Data referred to by an invariant is also invariant:
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span> <span class="d_keyword">char</span>[] s = <span class="d_string">"foo"</span>;
	s[0] = 'a';		<span class="d_comment">// error, invariant
</span></pre>

	<p>An implementation is allowed to replace an instance of an invariant
	declaration with the initializer for that declaration.
	Therefore, it is not legal to take the address of an invariant:
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span> <span class="d_keyword">int</span> i = 3;
	<span class="d_keyword">invariant</span>* p = &amp;i;	<span class="d_comment">// error, cannot take address of invariant
</span></pre>

	<p>Invariant members of a class or struct do not take up
	any space in instances of those objects:
	</p>

<pre class="d_code2">	<span class="d_keyword">struct</span> S
	{   <span class="d_keyword">int</span> x;
	    <span class="d_keyword">invariant</span> <span class="d_keyword">int</span> y;
	}

	writefln(S.sizeof);	<span class="d_comment">// prints 4, not 8
</span></pre>

	<p>The type of an invariant declaration is itself invariant.
	</p>

<h2>Const Storage Class</h2>

	<p>A const declaration is exactly like an invariant declaration,
	with the following differences:
	</p>

	<ul><li>Any data referenced by the const declaration cannot be
	changed from the const declaration, but it might be changed
	by other references to the same data.</li>

	<li>The type of a const declaration is itself const.</li>
	</ul>

<h2>Final Storage Class</h2>

	<p>A final declaration is one that, once initialized, can never
	change its value.
	</p>

<pre class="d_code2">	<span class="d_keyword">final</span> <span class="d_keyword">int</span> x = 3;
	x = 4;		<span class="d_comment">// error, x is final
</span></pre>

	<p>Final declarations can be initialized either by an initializer,
	or by a constructor:
	</p>

<pre class="d_code2">	<span class="d_keyword">final</span> <span class="d_keyword">int</span> x;
	<span class="d_keyword">static</span> <span class="d_keyword">this</span>()
	{
	    x = 4;	<span class="d_comment">// ok, can initialize final x inside constructor
</span>	    x = 5;	<span class="d_comment">// still ok, because still in constructor
</span>	}
	...
	x = 6;		<span class="d_comment">// error, x is final
</span>
	<span class="d_keyword">class</span> C
	{
	    <span class="d_keyword">final</span> <span class="d_keyword">int</span> s;
	    <span class="d_keyword">this</span>()
	    {	s = 3;	<span class="d_comment">// ok, can initialize in constructor
</span>	    }
	}
</pre>

	<p>Final declarations are stored and do take up space,
	therefore their address can be taken.
	</p>

	<p>Taking the address of a final variable of type T results in a
	type that's const(T)*.
	</p>

<pre class="d_code2">	<span class="d_keyword">final</span> <span class="d_keyword">int</span> x = 3;
	<span class="d_keyword">auto</span> p = &amp;x;		<span class="d_comment">// p is const(int)*
</span>	*p = 4;			<span class="d_comment">// error, *p is const
</span></pre>

	<p>Final declarations are themselves neither invariant nor const.
	</p>

<pre class="d_code2">	<span class="d_keyword">int</span> x = 4;
	<span class="d_keyword">final</span> <span class="d_keyword">int</span>* p = &amp;x;
	p = <span class="d_keyword">null</span>;		<span class="d_comment">// error, p is final
</span>	*p = 3;			<span class="d_comment">// ok, x is now 3
</span></pre>

<h2>Invariant Type</h2>

	<p>Data that will never change its value can be typed as invariant.
	The invariant keyword can be used as a <i>type constructor</i>:
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span>(<span class="d_keyword">char</span>)[] s = <span class="d_string">"hello"</span>;
</pre>

	<p>The invariant applies to the type within the following parentheses.
	So, while s can be assigned new values, the contents of s[] cannot
	be:
	</p>

<pre class="d_code2">	s[0] = 'b';	<span class="d_comment">// error, s[] is invariant
</span>	s = <span class="d_keyword">null</span>;	<span class="d_comment">// ok, s itself is not invariant
</span></pre>

	<p>Invariantness is transitive, meaning it applies to anything that
	can be referenced from the invariant type:
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span>(<span class="d_keyword">char</span>*)** p = ...;
	p = ...;	<span class="d_comment">// ok, p is not final
</span>	*p = ...;	<span class="d_comment">// *p is not invariant
</span>	**p = ...;	<span class="d_comment">// error, **p is invariant
</span>	***p = ...;	<span class="d_comment">// error, ***p is invariant
</span></pre>

	<p>The invariantness also only applies to what is referred to, not
	the declaration itself:
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span>(<span class="d_keyword">char</span>*) p = ...;
	p = ...;	<span class="d_comment">// ok, invariant doesn't apply to p itself
</span>	*p = ...;	<span class="d_comment">// error, invariant applies to what p refers to
</span></pre>

<h2>Creating Invariant Data</h2>

	<p>The first way is to use a literal that is already invariant,
	such as string literals. String literals are always invariant.
	</p>

<pre class="d_code2">	<span class="d_keyword">auto</span> s = <span class="d_string">"hello"</span>;   <span class="d_comment">// s is invariant(char)[5]
</span>	<span class="d_keyword">char</span>[] p = <span class="d_string">"world"</span>; <span class="d_comment">// error, cannot implicitly convert invariant
</span>			    <span class="d_comment">// to mutable
</span></pre>

	<p>The second way is to cast data to invariant.
	When doing so, it is up to the programmer to ensure that no
	other mutable references to the same data exist.
	</p>

<pre class="d_code2">	<span class="d_keyword">char</span>[] s = ...;
	<span class="d_keyword">invariant</span>(<span class="d_keyword">char</span>)[] p = <span class="d_keyword">cast</span>(<span class="d_keyword">invariant</span>)s;     <span class="d_comment">// undefined behavior
</span>	<span class="d_keyword">invariant</span>(<span class="d_keyword">char</span>)[] p = <span class="d_keyword">cast</span>(<span class="d_keyword">invariant</span>)s.dup; <span class="d_comment">// ok, unique reference
</span></pre>

	<p>The .idup property is a convenient way to create an invariant
	copy of an array:
	</p>

<pre class="d_code2">	<span class="d_keyword">auto</span> p = s.idup;
	p[0] = ...;	  <span class="d_comment">// error, p[] is invariant
</span></pre>

<h2>Removing Invariant With A Cast</h2>

	<p>The invariant type can be removed with a cast:
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span> <span class="d_keyword">int</span>* p = ...;
	<span class="d_keyword">int</span>* q = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)p;
</pre>

	<p>This does not mean, however, that one can change the data:
	</p>

<pre class="d_code2">	*q = 3; <span class="d_comment">// allowed by compiler, but result is undefined behavior
</span></pre>

	<p>The ability to cast away invariant-correctness is necessary in
	some cases where the static typing is incorrect and not fixable, such
	as when referencing code in a library one cannot change.
	Casting is, as always, a blunt and effective instrument, and
	when using it to cast away invariant-correctness, one must assume
	the responsibility to ensure the invariantness of the data, as
	the compiler will no longer be able to statically do so.
	</p>

<h2>Invariant Doesn't Apply To Declared Symbols</h2>

	<p>Consider the struct:
	</p>

<pre class="d_code2">	<span class="d_keyword">struct</span> S
	{
	    <span class="d_keyword">int</span> x;
	    <span class="d_keyword">int</span>* p;
	}
</pre>

	<p>In order to be able to use structs as user-defined wrappers
	for builtin types, it must be possible to declare a struct instance
	as having its members be mutable, but what it refers to to
	not be mutable. But all that's syntactically available is:
	</p>

<pre class="d_code2">	<span class="d_keyword">invariant</span>(S) s;
</pre>

	<p>Therefore, the invariant qualifier doesn't apply to the symbol
	itself being declared. It only applies to anything indirectly
	referenced by the symbol. Hence,
	</p>

<pre class="d_code2">	s.x = 3;   <span class="d_comment">// ok
</span>	*s.p = 3;  <span class="d_comment">// error, it's invariant
</span></pre>

	<p>For consistency's sake, then this must apply generally:
	</p>

<pre class="d_code2">	<span class="d_keyword">int</span> x;
	<span class="d_keyword">invariant</span>(<span class="d_keyword">int</span>*) p;
	p = <span class="d_keyword">cast</span>(<span class="d_keyword">invariant</span>)&amp;x;    <span class="d_comment">// ok
</span>	*p = 3;    <span class="d_comment">// error, invariant
</span>
	<span class="d_keyword">invariant</span>(<span class="d_keyword">int</span>) y;
	y = 3;        <span class="d_comment">// ok
</span>	<span class="d_keyword">auto</span> q = <span class="d_keyword">cast</span>(<span class="d_keyword">invariant</span>)&amp;y;  <span class="d_comment">// q's type is invariant(int)*
</span>	*q = 4;       <span class="d_comment">// error, invariant
</span></pre>

	<p>A similar situation applies to classes. Given:
	</p>

<pre class="d_code2">	<span class="d_keyword">class</span> C
	{
	    <span class="d_keyword">int</span> x;
	    <span class="d_keyword">int</span>* p;
	}

	<span class="d_keyword">invariant</span>(C) c;
	c = <span class="d_keyword">new</span> C;      <span class="d_comment">// (1) ok
</span>	c.x = 3;        <span class="d_comment">// (2) error, invariant
</span>	*c.p = 4;       <span class="d_comment">// (3) error, invariant
</span></pre>

	<p>Note that the c.x is an error, while the s.x is not. The reason is
	that c is already a reference type - so the invariant does not
	apply to c itself (1), but it does apply to what c refers to (2) and
	anything transitively referred to (3).
	</p>

<h2>Invariant Member Functions</h2>

	<p>Invariant member functions are guaranteed that the object
	and anything referred to by the this reference is invariant.
	They are declared as:
	</p>

<pre class="d_code2">	<span class="d_keyword">struct</span> S
	{   <span class="d_keyword">int</span> x;

	    <span class="d_keyword">invariant</span> <span class="d_keyword">void</span> foo()
	    {
		x = 4;	<span class="d_comment">// error, x is invariant
</span>		<span class="d_keyword">this</span>.x = 4;   <span class="d_comment">// error, x is invariant
</span>	    }
	}
</pre>

<h2>Const Type</h2>

	<p>Const types are like invariant types, except that const
	forms a read-only <i>view</i> of data. Other aliases to that
	same data may change it at any time.
	</p>

<h2>Const Member Functions</h2>

	<p>Const member functions are functions that are not allowed to
	change any part of the object through the member function's
	this reference.
	</p>

<h2>Implicit Conversions</h2>

	<p>Mutable and invariant types can be implicitly converted to const.
	Mutable types cannot be implicitly converted to invariant,
	and vice versa.
	</p>

<h2>Comparing D Invariant, Const and Final with C++ Const</h2>

	<table border=2 cellpadding=4 cellspacing=0 class="comp">
	<caption>Final, Const, Invariant Comparison</caption>

	<thead>
	<tr><th scope="col">Feature</th>
	<th scope="col">D</th>
	<th scope="col">C++98</th>
	</tr>
	</thead>

	<tbody>

	<tr><td>final keyword</td>
	<td>Yes</td>
	<td>No</td>
	</tr>

	<tr><td>const keyword</td>
	<td>Yes</td>
	<td>Yes</td>
	</tr>

	<tr><td>invariant keyword</td>
	<td>Yes</td>
	<td>No</td>
	</tr>

	<tr><td>const notation</td>
	<td>Functional:
<pre class="d_code2"><span class="d_comment">// ptr to const ptr to const int
</span><span class="d_keyword">const</span>(<span class="d_keyword">int</span>*)* p;
</pre>
	</td>
	<td>Postfix:
<pre class="cppcode"><span class="notranslate">// ptr to const ptr to const int
const int *const *p;
</span></pre>
	</td>
	</tr>

	<tr><td>transitive const</td>
	<td>Yes:
<pre class="d_code2"><span class="d_keyword">const</span> <span class="d_keyword">int</span>** p;  <span class="d_comment">// const ptr to const ptr to const int
</span>**p = 3;    <span class="d_comment">// error
</span></pre>
	 </td>
	<td>No:
<pre class="cppcode"><span class="notranslate">int** const p; // const ptr to ptr to int
**p = 3;    // ok
</span></pre>
	 </td>
	</tr>

	<tr><td>cast away const</td>
	<td>Yes:
<pre class="d_code2"><span class="d_keyword">const</span>(<span class="d_keyword">int</span>)* p;   <span class="d_comment">// ptr to const int
</span><span class="d_keyword">int</span>* q = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)p; <span class="d_comment">// ok
</span></pre>
	</td>
	<td>Yes:
<pre class="cppcode"><span class="notranslate">const int* p;   // ptr to const int
int* q = const_cast&lt;int*&gt;p; // ok
</span></pre>
	</td>
	</tr>

	<tr><td>modification after casting away const</td>
	<td>No:
<pre class="d_code2"><span class="d_keyword">const</span>(<span class="d_keyword">int</span>)* p;   <span class="d_comment">// ptr to const int
</span><span class="d_keyword">int</span>* q = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)p;
*q = 3;   <span class="d_comment">// undefined behavior
</span></pre>
	</td>
	<td>Yes:
<pre class="cppcode"><span class="notranslate">const int* p;   // ptr to const int
int* q = const_cast&lt;int*&gt;p;
*q = 3;   // ok
</span></pre>
	</td>
	</tr>

	<tr><td>overloading of top level const</td>
	<td>No:
<pre class="d_code2"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x);
<span class="d_keyword">void</span> foo(<span class="d_keyword">const</span> <span class="d_keyword">int</span> x);  <span class="d_comment">// error
</span></pre>
	</td>
	<td>No:
<pre class="cppcode"><span class="notranslate">void foo(int x);
void foo(const int x);  // error
</span></pre>
	</td>
	</tr>

	<tr><td>aliasing of const with mutable</td>
	<td>Yes:
<pre class="d_code2"><span class="d_keyword">void</span> foo(<span class="d_keyword">const</span> <span class="d_keyword">int</span>* x, <span class="d_keyword">int</span>* y)
{
   bar(*x); <span class="d_comment">// bar(3)
</span>   *y = 4;
   bar(*x); <span class="d_comment">// bar(4)
</span>}
...
<span class="d_keyword">int</span> i = 3;
foo(&amp;i, &amp;i);
</pre>
	</td>
	<td>Yes:
<pre class="cppcode"><span class="notranslate">void foo(const int* x, int* y)
{
   bar(*x); // bar(3)
   *y = 4;
   bar(*x); // bar(4)
}
...
int i = 3;
foo(&i, &i);
</span></pre>
	</td>
	</tr>

	<tr><td>aliasing of invariant with mutable</td>
	<td>Yes:
<pre class="d_code2"><span class="d_keyword">void</span> foo(<span class="d_keyword">invariant</span> <span class="d_keyword">int</span>* x, <span class="d_keyword">int</span>* y)
{
   bar(*x); <span class="d_comment">// bar(3)
</span>   *y = 4;  <span class="d_comment">// undefined behavior
</span>   bar(*x); <span class="d_comment">// bar(??)
</span>}
...
<span class="d_keyword">int</span> i = 3;
foo(<span class="d_keyword">cast</span>(<span class="d_keyword">invariant</span>)&amp;i, &amp;i);
</pre>
	</td>
	<td>No invariants</td>
	</tr>

	<tr><td>type of string literal</td>
	<td>invariant(char)[]</td>
	<td>const char*</td>
	</tr>


	<tr><td>implicit conversion of string literal to non-const</td>
	<td>not allowed</td>
	<td>allowed, but deprecated</td>
	</tr>

	</tbody>
	</table>


  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>



<div id="footernav">
<a href="http://www.digitalmars.com/NewsGroup.html" title="User Forums">Forums</a> |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/FinalConstInvariant" title="Read/write comments and feedback">Comments</a> |
<a href="index.html" title="D Programming Language" class="dlink">&nbsp;D&nbsp;</a> |
<a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2011 by Digital Mars &reg;, All Rights Reserved |
Page generated by <a href="ddoc.html">Ddoc</a>.
</div>
</body>
</html>
