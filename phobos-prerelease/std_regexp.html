<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.regexp - D Programming Language - Digital Mars</title>
<!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>-->
<script src="../js/codemirror.js"></script>
<script src="../js/d.js"></script>
<script src="../js/run.js" type="text/javascript"></script>
<link rel="stylesheet" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){return lastName(a) > lastName(b)});

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

<script src="../js/hyphenate.js" type="text/javascript"></script>

</head>

<body onload="listanchors()" class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="../images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="../images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="../images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul><li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul><li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul><li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul><li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul><li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update Tue Dec 25 16:32:10 2012
</span-->
	<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/regexp.d" class="tip button">
		Improve this page
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</a>
	<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/StdRegexp" class="tip button">
		Page wiki
		<span>
	        View or edit the community-maintained wiki page associated with this page.
		</span>
	</a>
</div>
    <h1>std.regexp</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/regexp.d -->
<span style="color:red">Deprecated.
       Please use <a href="std_regex.html">std.regex</a> instead.</span>
<p></p>
<a href="http://www.digitalmars.com/ctg/regular.html">Regular
 expressions</a> are a powerful method of string pattern matching.  The
 regular expression language used in this library is the same as
 that commonly used, however, some of the very advanced forms may
 behave slightly differently. The standard observed is the <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"> ECMA standard</a> for regular expressions.
<p></p>

 std.<a name="regexp"></a><span class="ddoc_psymbol">regexp</span> is designed to work only with valid UTF strings as input.
 To validate untrusted input, use std.utf.validate().
<p></p>

 In the following guide, <i>pattern</i>[] refers to a
 <a href="http://www.digitalmars.com/ctg/regular.html">regular expression</a>.
 The <i>attributes</i>[] refers to
 a string controlling the interpretation
 of the regular expression.
 It consists of a sequence of one or more
 of the following characters:
<p></p>

 <table border=1 cellspacing=0 cellpadding=5>
 <caption>Attribute Characters</caption>
 <tr><th>Attribute</th> <th>Action</th></tr>
 <tr>
 <td valign=top><b>g</b></td>
 <td valign=top>global; repeat over the whole input string</td>
 </tr>
 <tr>
 <td valign=top><b>i</b></td>
 <td valign=top>case insensitive</td>
 </tr>
 <tr>
 <td valign=top><b>m</b></td>
 <td valign=top>treat as multiple lines separated by newlines</td>
 </tr>
 </table>
<p></p>

 The <i>format</i>[] string has the formatting characters:
<p></p>

 <table border=1 cellspacing=0 cellpadding=5>
 <caption>Formatting Characters</caption>
 <tr><th>Format</th> <th>Replaced With</th></tr>
 <tr><td valign=top><b>$$</b></td>    <td valign=top>$</td>
 </tr>
 <tr><td valign=top><b>$&amp;</b></td>    <td valign=top>The matched substring.</td>
 </tr>
 <tr><td valign=top><b>$`</b></td>    <td valign=top>The portion of string that precedes the matched substring.</td>
 </tr>
 <tr><td valign=top><b>$'</b></td>    <td valign=top>The portion of string that follows the matched substring.</td>
 </tr>
 <tr><td valign=top><b>$</b><i>n</i></td> <td valign=top>The <i>n</i>th capture, where <i>n</i>
      is a single digit 1-9
      and <i>n</i> is not followed by a decimal digit.</td>
 </tr>
 <tr><td valign=top><b>$</b><i>nn</i></td> <td valign=top>The <i>nn</i>th capture, where <i>nn</i>
      is a two-digit decimal
      number 01-99.
      If <i>nn</i>th capture is undefined or more than the number
      of parenthesized subexpressions, use the empty
      string instead.</td>
 </tr>
 </table>
<p></p>

 Any other $ are left as is.

<p></p>
<b>References:</b><br>
<a href="http://en.wikipedia.org/wiki/Regular_expressions">Wikipedia</a>
<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br><a href="http://digitalmars.com">Walter Bright</a>
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/regexp.d">std/regexp.d</a><p></p>

<dl><dt class="d_decl"><a name=".email"></a>deprecated string <a name="email"></a><span class="ddoc_psymbol">email</span>;
</dt>
<dd>Regular expression to extract an email address.
<p></p>
<b>References:</b><br>
<a href="http://www.regular-expressions.info/email.html">How to Find or Validate an Email Address</a><br>
  <a href="http://tools.ietf.org/html/rfc2822#section-3.4.1">RFC 2822 Internet Message Format</a><p></p>

</dd>
<dt class="d_decl"><a name=".url"></a>deprecated string <a name="url"></a><span class="ddoc_psymbol">url</span>;
</dt>
<dd>Regular expression to extract a url <p></p>

</dd>
<dt class="d_decl"><a name=".RegExpException"></a>class <a name="RegExpException"></a><span class="ddoc_psymbol">RegExpException</span>: object.Exception;
</dt>
<dd>One of these gets thrown on compilation errors<p></p>

</dd>
<dt class="d_decl"><a name=".sub"></a>deprecated string <a name="sub"></a><span class="ddoc_psymbol">sub</span>(string <i>s</i>, string <i>pattern</i>, string <i>format</i>, string <i>attributes</i> = null);
</dt>
<dd>Search string for matches with regular expression
 <i>pattern</i> with <i>attributes</i>.
 Replace each match with string generated from <i>format</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>s</i></td>
<td valign=top>String to search.</td></tr>
<tr><td valign=top>string <i>pattern</i></td>
<td valign=top>Regular expression <i>pattern</i>.</td></tr>
<tr><td valign=top>string <i>format</i></td>
<td valign=top>Replacement string <i>format</i>.</td></tr>
<tr><td valign=top>string <i>attributes</i></td>
<td valign=top>Regular expression <i>attributes</i>.</td></tr>
</table><p></p>
<b>Returns:</b><br>the resulting string
<p></p>
<b>Example:</b><br>
Replace the letters 'a' with the letters 'ZZ'.
<pre class="d_code"> <span class="d_param">s</span> = <span class="d_string">"Strap a rocket engine on a chicken."</span>
 <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"a"</span>, <span class="d_string">"ZZ"</span>)        <span class="d_comment">// result: StrZZp a rocket engine on a chicken.
</span> <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"a"</span>, <span class="d_string">"ZZ"</span>, <span class="d_string">"g"</span>)   <span class="d_comment">// result: StrZZp ZZ rocket engine on ZZ chicken.
</span></pre>
  The replacement <i>format</i> can reference the matches using
  the $&amp;, $$, $', $`,  .. 9 notation:
<pre class="d_code"> <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"[ar]"</span>, <span class="d_string">"[$&amp;]"</span>, <span class="d_string">"g"</span>) <span class="d_comment">// result: St[r][a]p [a] [r]ocket engine on [a] chi
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".sub"></a>deprecated string <a name="sub"></a><span class="ddoc_psymbol">sub</span>(string <i>s</i>, string <i>pattern</i>, string delegate(RegExp) <i>dg</i>, string <i>attributes</i> = null);
</dt>
<dd>Search string for matches with regular expression
 <i>pattern</i> with <i>attributes</i>.
 Pass each match to delegate <i>dg</i>.
 Replace each match with the return value from <i>dg</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>s</i></td>
<td valign=top>String to search.</td></tr>
<tr><td valign=top>string <i>pattern</i></td>
<td valign=top>Regular expression <i>pattern</i>.</td></tr>
<tr><td valign=top>string delegate(RegExp) <i>dg</i></td>
<td valign=top>Delegate</td></tr>
<tr><td valign=top>string <i>attributes</i></td>
<td valign=top>Regular expression <i>attributes</i>.</td></tr>
</table><p></p>
<b>Returns:</b><br>the resulting string.
<p></p>
<b>Example:</b><br>
Capitalize the letters 'a' and 'r':
<pre class="d_code"> <span class="d_param">s</span> = <span class="d_string">"Strap a rocket engine on a chicken."</span>;
 <span class="d_psymbol">sub</span>(<span class="d_param">s</span>, <span class="d_string">"[ar]"</span>,
    <span class="d_keyword">delegate</span> <span class="d_keyword">char</span>[] (RegExp m)
    {
         <span class="d_keyword">return</span> toUpper(m[0]);
    },
    <span class="d_string">"g"</span>);    <span class="d_comment">// result: StRAp A Rocket engine on A chicken.
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".find"></a>deprecated ptrdiff_t <a name="find"></a><span class="ddoc_psymbol">find</span>(string <i>s</i>, RegExp <i>pattern</i>);
</dt>
<dd>Search <span class="d_param"><i>s</i>[]</span> for first match with <span class="d_param"><i>pattern</i></span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>s</i></td>
<td valign=top>String to search.</td></tr>
<tr><td valign=top>RegExp <i>pattern</i></td>
<td valign=top>Regular expression <i>pattern</i>.</td></tr>
</table><p></p>
<b>Returns:</b><br>index into <i>s</i>[] of match if found, -1 if no match.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> <span class="d_param">s</span> = <span class="d_string">"abcabcabab"</span>;
 <span class="d_psymbol">find</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"b"</span>));    <span class="d_comment">// match, returns 1
</span> <span class="d_psymbol">find</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"f"</span>));    <span class="d_comment">// no match, returns -1
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".find"></a>deprecated ptrdiff_t <a name="find"></a><span class="ddoc_psymbol">find</span>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</dt>
<dd><b>Returns:</b><br>Same as <span class="d_param"><a name="find"></a><span class="ddoc_psymbol">find</span>(<i>s</i>, RegExp(<i>pattern</i>, <i>attributes</i>))</span>.

<p></p>
<b>WARNING:</b><br>
This function is scheduled for deprecation due to unnecessary
   ambiguity with the homonym function in std.string. Instead of
   <span class="d_param">std.regexp.<a name="find"></a><span class="ddoc_psymbol">find</span>(<i>s</i>, p, a)</span>, you may want to use <span class="d_param">  <a name="find"></a><span class="ddoc_psymbol">find</span>(<i>s</i>, RegExp(p, a))</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".rfind"></a>deprecated ptrdiff_t <a name="rfind"></a><span class="ddoc_psymbol">rfind</span>(string <i>s</i>, RegExp <i>pattern</i>);
</dt>
<dd>Search <span class="d_param"><i>s</i>[]</span> for last match with <span class="d_param"><i>pattern</i></span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>s</i></td>
<td valign=top>String to search.</td></tr>
<tr><td valign=top>RegExp <i>pattern</i></td>
<td valign=top>Regular expression <i>pattern</i>.</td></tr>
</table><p></p>
<b>Returns:</b><br>index into <i>s</i>[] of match if found, -1 if no match.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> <span class="d_param">s</span> = <span class="d_string">"abcabcabab"</span>;
 <span class="d_psymbol">rfind</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"b"</span>));    <span class="d_comment">// match, returns 9
</span> <span class="d_psymbol">rfind</span>(<span class="d_param">s</span>, RegExp(<span class="d_string">"f"</span>));    <span class="d_comment">// no match, returns -1
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".rfind"></a>deprecated ptrdiff_t <a name="rfind"></a><span class="ddoc_psymbol">rfind</span>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</dt>
<dd><b>Returns:</b><br>Same as <span class="d_param"><a name="rfind"></a><span class="ddoc_psymbol">rfind</span>(<i>s</i>, RegExp(<i>pattern</i>, <i>attributes</i>))</span>.

<p></p>
<b>WARNING:</b><br>
This function is scheduled for deprecation due to unnecessary
ambiguity with the homonym function in std.string. Instead of
<span class="d_param">std.regexp.<a name="rfind"></a><span class="ddoc_psymbol">rfind</span>(<i>s</i>, p, a)</span>, you may want to use <span class="d_param"><a name="rfind"></a><span class="ddoc_psymbol">rfind</span>(<i>s</i>, RegExp(p, a))</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".split"></a>deprecated string[] <a name="split"></a><span class="ddoc_psymbol">split</span>(string <i>s</i>, RegExp <i>pattern</i>);
</dt>
<dd>Split <i>s</i>[] into an array of strings, using the regular
 expression <span class="d_param"><i>pattern</i></span> as the separator.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>s</i></td>
<td valign=top>String to search.</td></tr>
<tr><td valign=top>RegExp <i>pattern</i></td>
<td valign=top>Regular expression <i>pattern</i>.</td></tr>
</table><p></p>
<b>Returns:</b><br>array of slices into <i>s</i>[]
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">foreach</span> (<span class="d_param">s</span>; <span class="d_psymbol">split</span>(<span class="d_string">"abcabcabab"</span>, RegExp(<span class="d_string">"C."</span>, <span class="d_string">"i"</span>)))
 {
     writefln(<span class="d_string">"s = '%s'"</span>, <span class="d_param">s</span>);
 }
 <span class="d_comment">// Prints:
</span> <span class="d_comment">// s = 'ab'
</span> <span class="d_comment">// s = 'b'
</span> <span class="d_comment">// s = 'bab'
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".split"></a>deprecated string[] <a name="split"></a><span class="ddoc_psymbol">split</span>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</dt>
<dd><b>Returns:</b><br>Same as <span class="d_param"><a name="split"></a><span class="ddoc_psymbol">split</span>(<i>s</i>, RegExp(<i>pattern</i>, <i>attributes</i>))</span>.

<p></p>
<b>WARNING:</b><br>
This function is scheduled for deprecation due to unnecessary
ambiguity with the homonym function in std.string. Instead of
<span class="d_param">std.regexp.<a name="split"></a><span class="ddoc_psymbol">split</span>(<i>s</i>, p, a)</span>, you may want to use <span class="d_param"><a name="split"></a><span class="ddoc_psymbol">split</span>(<i>s</i>, RegExp(p, a))</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".search"></a>deprecated RegExp <a name="search"></a><span class="ddoc_psymbol">search</span>(string <i>s</i>, string <i>pattern</i>, string <i>attributes</i> = null);
</dt>
<dd>Search <i>s</i>[] for first match with <i>pattern</i>[] with <i>attributes</i>[].
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>s</i></td>
<td valign=top>String to <a name="search"></a><span class="ddoc_psymbol">search</span>.</td></tr>
<tr><td valign=top>string <i>pattern</i></td>
<td valign=top>Regular expression <i>pattern</i>.</td></tr>
<tr><td valign=top>string <i>attributes</i></td>
<td valign=top>Regular expression <i>attributes</i>.</td></tr>
</table><p></p>
<b>Returns:</b><br>corresponding RegExp if found, <b>null</b> if not.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">import</span> std.stdio;
 <span class="d_keyword">import</span> std.regexp;

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">if</span> (<span class="d_keyword">auto</span> m = std.regexp.<span class="d_psymbol">search</span>(<span class="d_string">"abcdef"</span>, <span class="d_string">"c"</span>))
     {
         writefln(<span class="d_string">"%s[%s]%s"</span>, m.pre, m[0], m.post);
     }
 }
 <span class="d_comment">// Prints:
</span> <span class="d_comment">// ab[c]def
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp"></a>class <a name="RegExp"></a><span class="ddoc_psymbol">RegExp</span>;
</dt>
<dd><a name="RegExp"></a><span class="ddoc_psymbol">RegExp</span> is a class to handle regular expressions.
<p></p>
It is the core foundation for adding powerful string pattern matching
 capabilities to programs like grep, text editors, awk, sed, etc.<p></p>

<dl><dt class="d_decl"><a name=".RegExp.this"></a> this(string <i>pattern</i>, string <i>attributes</i> = null);
</dt>
<dd>Construct a RegExp object. Compile <i>pattern</i>
 with <i><i>attributes</i></i> into
 an internal form for fast execution.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>pattern</i></td>
<td valign=top>regular expression</td></tr>
<tr><td valign=top>string <i>attributes</i></td>
<td valign=top>attributes</td></tr>
</table><p></p>
<b>Throws:</b><br>RegExpException if there are any compilation errors.
<p></p>
<b>Example:</b><br>
Declare two variables and assign to them a RegExp object:
<pre class="d_code"> <span class="d_keyword">auto</span> r = <span class="d_keyword">new</span> RegExp(<span class="d_string">"pattern"</span>);
 <span class="d_keyword">auto</span> s = <span class="d_keyword">new</span> RegExp(<span class="d_string">r"p[1-5]\s*"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.opCall"></a>static RegExp <a name="opCall"></a><span class="ddoc_psymbol">opCall</span>(string <i>pattern</i>, string <i>attributes</i> = null);
</dt>
<dd>Generate instance of RegExp.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>pattern</i></td>
<td valign=top>regular expression</td></tr>
<tr><td valign=top>string <i>attributes</i></td>
<td valign=top>attributes</td></tr>
</table><p></p>
<b>Throws:</b><br>RegExpException if there are any compilation errors.
<p></p>
<b>Example:</b><br>
Declare two variables and assign to them a RegExp object:
<pre class="d_code"> <span class="d_keyword">auto</span> r = RegExp(<span class="d_string">"pattern"</span>);
 <span class="d_keyword">auto</span> s = RegExp(<span class="d_string">r"p[1-5]\s*"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.search"></a>RegExp <a name="search"></a><span class="ddoc_psymbol">search</span>(<i>string</i> <i>string</i>);
<br><a name=".RegExp.opApply"></a>int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(scope int delegate(ref RegExp) <i>dg</i>);
</dt>
<dd>Set up for start of foreach loop.
<p></p>
<b>Returns:</b><br><a name="search"></a><span class="ddoc_psymbol">search</span>() returns instance of RegExp set up to search <i>string</i>[].
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">import</span> std.stdio;
 <span class="d_keyword">import</span> std.regexp;

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">foreach</span>(m; RegExp(<span class="d_string">"ab"</span>).<span class="d_psymbol">search</span>(<span class="d_string">"abcabcabab"</span>))
     {
         writefln(<span class="d_string">"%s[%s]%s"</span>, m.pre, m[0], m.post);
     }
 }
 <span class="d_comment">// Prints:
</span> <span class="d_comment">// [ab]cabcabab
</span> <span class="d_comment">// abc[ab]cabab
</span> <span class="d_comment">// abcabc[ab]ab
</span> <span class="d_comment">// abcabcab[ab]
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.opIndex"></a>string <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>n</i>);
</dt>
<dd>Retrieve match <i>n</i>.
<p></p>
<i>n</i>==0 means the matched substring, <i>n</i>&gt;0 means the
 <i>n</i>'th parenthesized subexpression.
 if <i>n</i> is larger than the number of parenthesized subexpressions,
 <b>null</b> is returned.<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.match"></a>string <a name="match"></a><span class="ddoc_psymbol">match</span>(size_t <i>n</i>);
</dt>
<dd>Same as <span class="d_param">opIndex(<i>n</i>)</span>.
<p></p>
<b>WARNING:</b><br>
Scheduled for deprecation due to confusion with overloaded
       <span class="d_param"><a name="match"></a><span class="ddoc_psymbol">match</span>(string)</span>. Instead of <span class="d_param">regex.<a name="match"></a><span class="ddoc_psymbol">match</span>(<i>n</i>)</span>
       you may want to use <span class="d_param">regex[<i>n</i>]</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.pre"></a>@property string <a name="pre"></a><span class="ddoc_psymbol">pre</span>();
</dt>
<dd>Return the slice of the input that precedes the matched substring.<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.post"></a>@property string <a name="post"></a><span class="ddoc_psymbol">post</span>();
</dt>
<dd>Return the slice of the input that follows the matched substring.<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.split"></a>string[] <a name="split"></a><span class="ddoc_psymbol">split</span>(string <i>s</i>);
</dt>
<dd>Split <i>s</i>[] into an array of strings, using the regular
 expression as the separator.
<p></p>
<b>Returns:</b><br>array of slices into <i>s</i>[]<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.find"></a>ptrdiff_t <a name="find"></a><span class="ddoc_psymbol">find</span>(<i>string</i> <i>string</i>);
</dt>
<dd>Search <i>string</i>[] for match with regular expression.
<p></p>
<b>Returns:</b><br>index of match if successful, -1 if not found<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.match"></a>string[] <a name="match"></a><span class="ddoc_psymbol">match</span>(string <i>s</i>);
</dt>
<dd>Search <i>s</i>[] for <a name="match"></a><span class="ddoc_psymbol">match</span>.
<p></p>
<b>Returns:</b><br>If global attribute, return same value as exec(<i>s</i>).
  If not global attribute, return array of all matches.<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.replace"></a>string <a name="replace"></a><span class="ddoc_psymbol">replace</span>(string <i>s</i>, string <i>format</i>);
</dt>
<dd>Find regular expression matches in <i>s</i>[]. Replace those matches
 with a new string composed of <i>format</i>[] merged with the result of the
 matches.
 If global, <a name="replace"></a><span class="ddoc_psymbol">replace</span> all matches. Otherwise, <a name="replace"></a><span class="ddoc_psymbol">replace</span> first match.
<p></p>
<b>Returns:</b><br>the new string<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.exec"></a>string[] <a name="exec"></a><span class="ddoc_psymbol">exec</span>(string <i>s</i>);
</dt>
<dd>Search string[] for match.
<p></p>
<b>Returns:</b><br>array of slices into string[] representing matches<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.exec"></a>string[] <a name="exec"></a><span class="ddoc_psymbol">exec</span>();
</dt>
<dd>Pick up where last <a name="exec"></a><span class="ddoc_psymbol">exec</span>(string) or <a name="exec"></a><span class="ddoc_psymbol">exec</span>() left off,
 searching string[] for next match.
<p></p>
<b>Returns:</b><br>array of slices into string[] representing matches<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.test"></a>bool <a name="test"></a><span class="ddoc_psymbol">test</span>(string <i>s</i>);
</dt>
<dd>Search <i>s</i>[] for match.
<p></p>
<b>Returns:</b><br>0 for no match, !=0 for match
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.regexp;
<span class="d_keyword">import</span> std.string;

<span class="d_keyword">int</span> grep(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">char</span>[]) pred, <span class="d_keyword">char</span>[][] list)
{
  <span class="d_keyword">int</span> count;
  <span class="d_keyword">foreach</span> (<span class="d_param">s</span>; list)
  {  <span class="d_keyword">if</span> (pred(<span class="d_param">s</span>))
       ++count;
  }
  <span class="d_keyword">return</span> count;
}

<span class="d_keyword">void</span> main()
{
  <span class="d_keyword">auto</span> x = grep(&amp;RegExp(<span class="d_string">"[Ff]oo"</span>).<span class="d_psymbol">test</span>,
                std.string.split(<span class="d_string">"mary had a foo lamb"</span>));
  writefln(x);
}
</pre>
 which prints: 1<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.test"></a>int <a name="test"></a><span class="ddoc_psymbol">test</span>();
</dt>
<dd>Pick up where last <a name="test"></a><span class="ddoc_psymbol">test</span>(string) or <a name="test"></a><span class="ddoc_psymbol">test</span>() left off, and search again.
<p></p>
<b>Returns:</b><br>0 for no match, !=0 for match<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.test"></a>int <a name="test"></a><span class="ddoc_psymbol">test</span>(string <i>s</i>, size_t <i>startindex</i>);
</dt>
<dd>Test <i>s</i>[] starting at <i>startindex</i> against regular expression.
<p></p>
<b>Returns:</b><br>0 for no match, !=0 for match<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.replace"></a>string <a name="replace"></a><span class="ddoc_psymbol">replace</span>(string <i>format</i>);
</dt>
<dd>After a match is found with test(), this function
 will take the match results and, using the <i>format</i>
 string, generate and return a new string.<p></p>

</dd>
<dt class="d_decl"><a name=".RegExp.replaceOld"></a>string <a name="replaceOld"></a><span class="ddoc_psymbol">replaceOld</span>(string <i>format</i>);
</dt>
<dd>Like replace(char[] <i>format</i>), but uses old style formatting:
        <table border=1 cellspacing=0 cellpadding=5>
        <th>Format
        <th>Description
        <tr>
        <td><b>&amp;</b>
        <td>replace with the match
        </tr>
        <tr>
        <td><b>\</b><i>n</i>
        <td>replace with the <i>n</i>th parenthesized match, <i>n</i> is 1..9
        </tr>
        <tr>
        <td><b>\</b><i>c</i>
        <td>replace with char <i>c</i>.
        </tr>
        </table><p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<!--<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">-->
</script>
</div><!--/content-->


<div id="copyright">
Copyright Digital Mars 2000 - 2011.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
