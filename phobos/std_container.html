<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.container - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script>
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
    values[n++] = a.name
    }

    values.sort();

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        newText += '<a href="#' + a + '"><span class="d_psymbol">'
                + a + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

<script src="/js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body onload="listanchors()" class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="images/search-button.gif" />
			<input type="hidden" id="domains" name="domains" value="d-programming-language.org" />
			<input type="hidden" id="sourceid" name="sourceid" value="google-search" />
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="d-programming-language.org">Entire D  Site</option>
					<option value="d-programming-language.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul><li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul><li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul><li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_gregorian.html" title="Gregorian Calendar">std.gregorian</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_regexp.html" title="regular expressions (deprecated)">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
    <h2><a href="phobos.html#core" title="D core modules">core</a></h2>
    <ul><li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>std.container</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/container.d -->
Defines generic containers.
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/container.d">std/container.d</a>
<p></p>
<b>License:</b><br>Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at <a href="http://boost.org/LICENSE_1_0.txt">boost.org/LICENSE_1_0.txt</a>).

<p></p>
<b>Authors:</b><br>Steven Schveighoffer, <a href="http://erdani.com">Andrei Alexandrescu</a>
<p></p>

<center><table cellspacing=0 cellpadding=5 valign=top class=book><caption>Container primitives. Below, <span class="d_inlinecode">C</span> means
a container type, <span class="d_inlinecode">c</span> is a value of container type, <span class="d_inlinecode">n<sub>x</sub></span> represents the effective length of value <span class="d_inlinecode">x</span>, which could be a
single element (in which case <span class="d_inlinecode">n<sub>x</sub></span> is <span class="d_inlinecode">1</span>), a container,
or a range.</caption><p></p>

<tr><th>Syntax</th> <th><b><i>&Omicron;</i>(</b><span class="d_inlinecode">&middot;</span><b><i>)</i></b></th> <th>Description</th></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">C(x)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>x</sub></span></td> <td valign=top>Creates a
container of type <span class="d_inlinecode">C</span> from either another container or a range.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.dup</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Returns a
duplicate of the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c ~ x</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n<sub>x</sub></span></td> <td valign=top>Returns the concatenation of <span class="d_inlinecode">c</span> and <span class="d_inlinecode">r</span>. <span class="d_inlinecode">x</span> may be a single
element or an input range.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">x ~ c</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n<sub>x</sub></span></td> <td valign=top>Returns the concatenation of <span class="d_inlinecode">x</span> and <span class="d_inlinecode">c</span>.  <span class="d_inlinecode">x</span> may be a
single element or an input range type.</td></tr>
<p></p>

<tr style=leadingrow bgcolor=#E4E9EF><td colspan=3><b><em>Iteration</em></b></td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.Range</span></td> <td valign=top></td> <td valign=top>The primary range
type associated with the container.</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c[]</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range
iterating over the entire container, in a container-defined order.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[a, b]</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Fetches a
portion of the container from key <span class="d_inlinecode">a</span> to key <span class="d_inlinecode">b</span>.</td></tr>
<p></p>

<tr style=leadingrow bgcolor=#E4E9EF><td colspan=3><b><em>Capacity</em></b></td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.empty</span></td> <td valign=top><span class="d_inlinecode">1</span></td> <td valign=top>Returns <span class="d_inlinecode"><b>true</b></span> if the
container has no elements, <span class="d_inlinecode"><b>false</b></span> otherwise.</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.length</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
number of elements in the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.length = n</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n</span></td> <td valign=top>Forces
the number of elements in the container to <span class="d_inlinecode">n</span>. If the container
ends up growing, the added elements are initialized in a
container-dependent manner (usually with <span class="d_inlinecode">T.init</span>).</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.capacity</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
maximum number of elements that can be stored in the container
without triggering a reallocation.</td></tr>
<p></p>

<tr><td valign=top><span class="d_inlinecode">c.reserve(x)</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Forces <span class="d_inlinecode">capacity</span> to at least <span class="d_inlinecode">x</span> without reducing it.</td></tr>
<p></p>

<tr style=leadingrow bgcolor=#E4E9EF><td colspan=3><b><em>Access</em></b></td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.front</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
first element of the container, in a container-defined order.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.moveFront</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Destructively reads and returns the first element of the
container. The slot is not removed from the container; it is left
initalized with <span class="d_inlinecode">T.init</span>. This routine need not be defined if <span class="d_inlinecode">front</span> returns a <span class="d_inlinecode">ref</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.front = v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Assigns
<span class="d_inlinecode">v</span> to the first element of the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.back</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns the
last element of the container, in a container-defined order.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.moveBack</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Destructively reads and returns the first element of the
<a name="container"></a><span class="ddoc_psymbol">container</span>. The slot is not removed from the container; it is left
initalized with <span class="d_inlinecode">T.init</span>. This routine need not be defined if <span class="d_inlinecode">front</span> returns a <span class="d_inlinecode">ref</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.back = v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Assigns
<span class="d_inlinecode">v</span> to the last element of the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[x]</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Provides
indexed access into the container. The index type is
container-defined. A <a name="container"></a><span class="ddoc_psymbol">container</span> may define several index types (and
consequently overloaded indexing).</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.moveAt(x)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Destructively reads and returns the value at position <span class="d_inlinecode">x</span>. The slot
is not removed from the container; it is left initialized with <span class="d_inlinecode">T.init</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[x] = v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Sets
element at specified index into the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c[x] <i>op</i>= v</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Performs read-modify-write operation at specified index into the
container.</td></tr>
<p></p>

<tr style=leadingrow bgcolor=#E4E9EF><td colspan=3><b><em>Operations</em></b></td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">e in c</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns nonzero if e is found in <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.lowerBound(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range of all elements strictly less than <span class="d_inlinecode">v</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.upperBound(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range of all elements strictly greater than <span class="d_inlinecode">v</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.equalRange(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td> <td valign=top>Returns a range of all elements in <span class="d_inlinecode">c</span> that are equal to <span class="d_inlinecode">v</span>.</td></tr>
<p></p>

<tr style=leadingrow bgcolor=#E4E9EF><td colspan=3><b><em>Modifiers</em></b></td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c ~= x</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub> + n<sub>x</sub></span></td>
<td valign=top>Appends <span class="d_inlinecode">x</span> to <span class="d_inlinecode">c</span>. <span class="d_inlinecode">x</span> may be a single element or an
input range type.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.clear()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Removes all
elements in <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.insert(x)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>x</sub> * log n<sub>c</sub></span></td>
<td valign=top>Inserts <span class="d_inlinecode">x</span> in <span class="d_inlinecode">c</span> at a position (or positions) chosen by <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableInsert(x)</span></td>
<td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>x</sub> * log n<sub>c</sub></span></td> <td valign=top>Same as <span class="d_inlinecode">c.insert(x)</span>,
but is guaranteed to not invalidate any ranges.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.linearInsert(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td> <td valign=top>Same
as <span class="d_inlinecode">c.insert(v)</span> but relaxes complexity to linear.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableLinearInsert(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.stableInsert(v)</span> but relaxes complexity to linear.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeAny()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes some element from <span class="d_inlinecode">c</span> and returns it.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemoveAny(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeAny(v)</span>, but is guaranteed to not invalidate any
iterators.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.insertFront(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Inserts <span class="d_inlinecode">v</span> at the front of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableInsertFront(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.insertFront(v)</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.insertBack(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Inserts <span class="d_inlinecode">v</span> at the back of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableInsertBack(v)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.insertBack(v)</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeFront()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes the element at the front of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemoveFront()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeFront()</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeBack()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes the value at the back of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemoveBack()</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeBack()</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.remove(r)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>r</sub> * log n<sub>c</sub></span></td>
<td valign=top>Removes range <span class="d_inlinecode">r</span> from <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableRemove(r)</span></td>
<td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>r</sub> * log n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.remove(r)</span>, but guarantees iterators are not
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.linearRemove(r)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td>
<td valign=top>Removes range <span class="d_inlinecode">r</span> from <span class="d_inlinecode">c</span>.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.stableLinearRemove(r)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">n<sub>c</sub></span></td>
<td valign=top>Same as <span class="d_inlinecode">c.linearRemove(r)</span>, but guarantees iterators are not
invalidated.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode">c.removeKey(k)</span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode">log n<sub>c</sub></span></td>
<td valign=top>Removes an element from <span class="d_inlinecode">c</span> by using its key <span class="d_inlinecode">k</span>.
The key's type is defined by the container.</td></tr>
<p></p>

<tr><td valign=top class="donthyphenate"><span class="d_inlinecode"></span></td> <td valign=top class="donthyphenate"><span class="d_inlinecode"></span></td> <td valign=top></td></tr>
<p></p>

</table></center><p></p>

<dl><dt><div class="d_decl">Container <a name="make"></a><span class="ddoc_psymbol">make</span>(Container, T...)(T <i>arguments</i>);
<br>Container <a name="make"></a><span class="ddoc_psymbol">make</span>(Container, T...)(T <i>arguments</i>);
</div></dt>
<dd>Returns an initialized container. This function is mainly for
eliminating construction differences between <span class="d_inlinecode">class</span> containers and
<span class="d_inlinecode">struct</span> containers.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="SList"></a><span class="ddoc_psymbol">SList</span>(T);
</div></dt>
<dd>Implements a simple and fast singly-linked list.<p></p>

<dl><dt><div class="d_decl">template <a name="__ctor"></a><span class="ddoc_psymbol">__ctor</span>(U) if (isImplicitlyConvertible!(U,T))</div></dt>
<dd>Constructor taking a number of nodes<p></p>

</dd>
<dt><div class="d_decl">template <a name="__ctor"></a><span class="ddoc_psymbol">__ctor</span>(Stuff) if (isInputRange!(Stuff) &amp;&amp; isImplicitlyConvertible!(ElementType!(Stuff),T) &amp;&amp; !is(Stuff == T[]))</div></dt>
<dd>Constructor taking an input range<p></p>

</dd>
<dt><div class="d_decl">const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const SList <i>rhs</i>);
</div></dt>
<dd>Comparison for equality.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">min(n, n1)</span><b><i>)</i></b> where <span class="d_inlinecode">n1</span> is the number of
elements in <span class="d_inlinecode"><i>rhs</i></span>.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</div></dt>
<dd>Defines the container's primary range, which embodies a forward range.<p></p>

<dl><dt><div class="d_decl">const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br>Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br>void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
<br>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</div></dt>
<dd>Forward range primitives.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</div></dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">SList <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</div></dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</div></dt>
<dd>Returns a range that iterates over all elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">T <a name="front"></a><span class="ddoc_psymbol">front</span>();
</div></dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
</div></dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span>(<i>value</i>)</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">template <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op,Stuff) if (op == "~" &amp;&amp; is(typeof(SList(rhs))))</div></dt>
<dd>Returns a new <span class="d_inlinecode">SList</span> that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span></span>.<p></p>

<dl><dt><div class="d_decl">SList <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(Stuff <i>rhs</i>);
</div></dt>
<dd>Returns a new <span class="d_inlinecode">SList</span> that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span></span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</div></dt>
<dd>Removes all contents from the <span class="d_inlinecode">SList</span>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">template <a name="insertFront"></a><span class="ddoc_psymbol">insertFront</span>(Stuff) if (isInputRange!(Stuff) &amp;&amp; isImplicitlyConvertible!(ElementType!(Stuff),T))<br>template <a name="insertFront"></a><span class="ddoc_psymbol">insertFront</span>(Stuff) if (isImplicitlyConvertible!(Stuff,T))<br>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span>;
<br>alias <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>;
<br>alias <a name="stableInsertFront"></a><span class="ddoc_psymbol">stableInsertFront</span>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> to the front of the container. <span class="d_inlinecode">stuff</span> can be a
value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that ranges
iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

<dl><dt><div class="d_decl">size_t <a name="insertFront"></a><span class="ddoc_psymbol">insertFront</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode"><i>stuff</i></span> to the front of the container. <span class="d_inlinecode"><i>stuff</i></span> can be a
value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that ranges
iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span>;
</div></dt>
<dd>Picks one value from the front of the container, removes it from the
container, and returns it.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>();
<br>alias <a name="stableRemoveFront"></a><span class="ddoc_psymbol">stableRemoveFront</span>;
</div></dt>
<dd>Removes the value at the front of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>(size_t <i>howMany</i>);
<br>alias <a name="stableRemoveFront"></a><span class="ddoc_psymbol">stableRemoveFront</span>;
</div></dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> after range <span class="d_inlinecode">r</span>, which must be a range
previously extracted from this container. Given that all ranges for a
list end at the end of the list, this function essentially appends to
the list and uses <span class="d_inlinecode">r</span> as a potentially fast way to reach the last
node in the list. (Ideally <span class="d_inlinecode">r</span> is positioned near or at the last
element of the list.)
<p></p>
<span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects
convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but
guarantees that ranges iterating over the container are never
invalidated.

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">k + m</span><b><i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode">r</span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span>.<p></p>

<dl><dt><div class="d_decl">size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Range <i>r</i>, Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode"><i>stuff</i></span> after range <span class="d_inlinecode"><i>r</i></span>, which must be a range
previously extracted from this container. Given that all ranges for a
list end at the end of the list, this function essentially appends to
the list and uses <span class="d_inlinecode"><i>r</i></span> as a potentially fast way to reach the last
node in the list. (Ideally <span class="d_inlinecode"><i>r</i></span> is positioned near or at the last
element of the list.)
<p></p>
<span class="d_inlinecode"><i>stuff</i></span> can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects
convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but
guarantees that ranges iterating over the container are never
invalidated.

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">k + m</span><b><i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode"><i>r</i></span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode"><i>stuff</i></span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">template <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)<br>alias <a name="stableInsertAfter"></a><span class="ddoc_psymbol">stableInsertAfter</span>;
</div></dt>
<dd>Similar to <span class="d_inlinecode"><a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span></span> above, but accepts a range bounded in
count. This is important for ensuring fast insertions in the middle of
the list.  For fast insertions after a specified position <span class="d_inlinecode">r</span>, use
<span class="d_inlinecode"><a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(take(r, 1), stuff)</span>. The complexity of that operation
only depends on the number of elements in <span class="d_inlinecode">stuff</span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">r.original.empty || r.maxLength &gt; 0</span>

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">k + m</span><b><i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode">r</span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span>.<p></p>

<dl><dt><div class="d_decl">size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Take!(Range) <i>r</i>, Stuff <i>stuff</i>);
</div></dt>
<dd>Similar to <span class="d_inlinecode"><a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span></span> above, but accepts a range bounded in
count. This is important for ensuring fast insertions in the middle of
the list.  For fast insertions after a specified position <span class="d_inlinecode"><i>r</i></span>, use
<span class="d_inlinecode"><a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(take(<i>r</i>, 1), <i>stuff</i>)</span>. The complexity of that operation
only depends on the number of elements in <span class="d_inlinecode"><i>stuff</i></span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>r</i>.original.empty || <i>r</i>.maxLength &gt; 0</span>

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">k + m</span><b><i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode"><i>r</i></span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode"><i>stuff</i></span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
</div></dt>
<dd>Removes a range from the list in linear time.
<p></p>
<b>Returns:</b><br>An empty range.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Take!(Range) <i>r</i>);
<br>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span>;
</div></dt>
<dd>Removes a <span class="d_inlinecode">Take!Range</span> from the list in linear time.
<p></p>
<b>Returns:</b><br>A range comprehending the elements after the removed range.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="Array"></a><span class="ddoc_psymbol">Array</span>(T) if (!is(T : const(bool)));
</div></dt>
<dd><a name="Array"></a><span class="ddoc_psymbol">Array</span> type with deterministic control of memory. The memory allocated
for the array is reclaimed as soon as possible; there is no reliance
on the garbage collector. <span class="d_inlinecode"><a name="Array"></a><span class="ddoc_psymbol">Array</span></span> uses <span class="d_inlinecode">malloc</span> and <span class="d_inlinecode">free</span>
for managing its own memory.<p></p>

<dl><dt><div class="d_decl">const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const Array <i>rhs</i>);
</div></dt>
<dd>Comparison for equality.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</div></dt>
<dd>Defines the container's primary range, which is a random-access range.<p></p>

</dd>
<dt><div class="d_decl">const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</div></dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Array <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</div></dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">const size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</div></dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</div></dt>
<dd>Returns the maximum number of elements the container can store without
   (a) allocating memory, (b) invalidating iterators upon insertion.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="reserve"></a><span class="ddoc_psymbol">reserve</span>(size_t <i>elements</i>);
</div></dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">e</span> <i>elements</i>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= e</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</div></dt>
<dd>Returns a range that iterates over elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>a</i>, size_t <i>b</i>);
</div></dt>
<dd>Returns <i>a</i> range that iterates over elements of the container from
index <span class="d_inlinecode"><i>a</i></span> up to (excluding) index <span class="d_inlinecode"><i>b</i></span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>a</i> &lt;= <i>b</i> &amp;&amp; <i>b</i> &lt;= length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">const size_t <a name="opDollar"></a><span class="ddoc_psymbol">opDollar</span>();
</div></dt>
<dd>@@@BUG@@@ This doesn't work yet<p></p>

</dd>
<dt><div class="d_decl">T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br>void <a name="front"></a><span class="ddoc_psymbol">front</span>(T <i>value</i>);
<br>T <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br>void <a name="back"></a><span class="ddoc_psymbol">back</span>(T <i>value</i>);
</div></dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span> and <span class="d_inlinecode">opSlice().back</span>, respectively.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">T <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
<br>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(T <i>value</i>, size_t <i>i</i>);
<br>template <a name="opIndexOpAssign"></a><span class="ddoc_psymbol">opIndexOpAssign</span>(string op)</div></dt>
<dd>Indexing operators yield or modify the value at a specified index.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>i</i> &lt; length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">template <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op,Stuff) if (op == "~")</div></dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements in <span class="d_inlinecode">stuff</span><p></p>

<dl><dt><div class="d_decl">Array <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements in <span class="d_inlinecode"><i>stuff</i></span><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">template <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op,Stuff) if (op == "~")</div></dt>
<dd>Forwards to <span class="d_inlinecode">insertBack(stuff)</span>.<p></p>

<dl><dt><div class="d_decl">void <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Forwards to <span class="d_inlinecode">insertBack(<i>stuff</i>)</span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</div></dt>
<dd>Removes all contents from the container. The container decides how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="length"></a><span class="ddoc_psymbol">length</span>(size_t <i>newLength</i>);
</div></dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span></span>, the added elements are added to
unspecified positions in the container and initialized with <span class="d_inlinecode">T.init</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b><i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span> == <i>newLength</i></span><p></p>

</dd>
<dt><div class="d_decl">T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span>;
</div></dt>
<dd>Picks one value in an unspecified position in the container, removes
it from the container, and returns it. Implementations should pick the
value that's the most advantageous for the container, but document the
exact behavior. The stable version behaves the same, but guarantees
that ranges iterating over the container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff) if (isImplicitlyConvertible!(Stuff,T) || isInputRange!(Stuff) &amp;&amp; isImplicitlyConvertible!(ElementType!(Stuff),T))<br>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the front or back of the container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
elements in <span class="d_inlinecode">stuff</span><p></p>

<dl><dt><div class="d_decl">size_t <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the front or back of the container. <span class="d_inlinecode"><i>stuff</i></span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
elements in <span class="d_inlinecode"><i>stuff</i></span><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
<br>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span>;
</div></dt>
<dd>Removes the value at the back of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>(size_t <i>howMany</i>);
<br>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span>;
</div></dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i></span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff) if (isImplicitlyConvertible!(Stuff,T))<br>template <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff) if (isInputRange!(Stuff) &amp;&amp; isImplicitlyConvertible!(ElementType!(Stuff),T))<br>template <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)<br>template <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff) if (isInputRange!(Stuff) &amp;&amp; isImplicitlyConvertible!(ElementType!(Stuff),T))<br>template <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff) if (isImplicitlyConvertible!(Stuff,T))</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>, which must
be a valid range previously extracted from this container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

<dl><dt><div class="d_decl">size_t <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Range <i>r</i>, Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode"><i>stuff</i></span> before, after, or instead range <span class="d_inlinecode"><i>r</i></span>, which must
be a valid range previously extracted from this container. <span class="d_inlinecode"><i>stuff</i></span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode"><i>stuff</i></span><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
<br>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span>;
</div></dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
obtained originally from this container. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n - m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of elements in
<span class="d_inlinecode"><i>r</i></span><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span>(Store,alias less = "a &lt; b") if (isRandomAccessRange!(Store) || isRandomAccessRange!(typeof(Store.init[])));
</div></dt>
<dd>Implements a <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heap</a>
container on top of a given random-access range type (usually <span class="d_inlinecode">T[]</span>) or a random-access container type (usually <span class="d_inlinecode">Array!T</span>). The
documentation of <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> will refer to the underlying range or
container as the <i>store</i> of the heap.
<p></p>
The binary heap induces structure over the underlying store such that
accessing the largest element (by using the <span class="d_inlinecode">front</span> property) is a
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b> operation and extracting it (by using the <span class="d_inlinecode">removeFront()</span> method) is done fast in <b><i>&Omicron;</i>(</b><span class="d_inlinecode">log n</span><b><i>)</i></b> time.
<p></p>

If <span class="d_inlinecode">less</span> is the less-than operator, which is the default option,
then <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> defines a so-called max-heap that optimizes
extraction of the <i>largest</i> elements. To define a min-heap,
instantiate <a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span> with <span class="d_inlinecode">"a &gt; b"</span> as its predicate.
<p></p>

Simply extracting elements from a <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> container is
tantamount to lazily fetching elements of <span class="d_inlinecode">Store</span> in descending
order. Extracting elements from the <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> to completion
leaves the underlying store sorted in ascending order but, again,
yields elements in descending order.
<p></p>

If <span class="d_inlinecode">Store</span> is a range, the <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> cannot grow beyond the
size of that range. If <span class="d_inlinecode">Store</span> is a container that supports <span class="d_inlinecode">insertBack</span>, the <span class="d_inlinecode"><a name="BinaryHeap"></a><span class="ddoc_psymbol">BinaryHeap</span></span> may grow by adding elements to the
container.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Example from "Introduction to Algorithms" Cormen et al, p 146
</span><span class="d_keyword">int</span>[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];
<span class="d_keyword">auto</span> h = heapify(a);
<span class="d_comment">// largest element
</span><span class="d_keyword">assert</span>(h.front == 16);
<span class="d_comment">// a has the heap property
</span><span class="d_keyword">assert</span>(equal(a, [ 16, 14, 10, 9, 8, 7, 4, 3, 2, 1 ]));
</pre>
<p></p>

<dl><dt><div class="d_decl"><a name="__ctor"></a><span class="ddoc_psymbol">__ctor</span>;
</div></dt>
<dd>Converts the store <span class="d_inlinecode">s</span> into a heap. If <span class="d_inlinecode">initialSize</span> is
       specified, only the first <span class="d_inlinecode">initialSize</span> elements in <span class="d_inlinecode">s</span>
       are transformed into a heap, after which the heap can grow up
       to <span class="d_inlinecode">r.length</span> (if <span class="d_inlinecode">Store</span> is a range) or indefinitely (if
       <span class="d_inlinecode">Store</span> is a container with <span class="d_inlinecode">insertBack</span>). Performs
       <b><i>&Omicron;</i>(</b><span class="d_inlinecode">min(r.length, initialSize)</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">less</span>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="acquire"></a><span class="ddoc_psymbol">acquire</span>(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</div></dt>
<dd>Takes ownership of a store. After this, manipulating <span class="d_inlinecode"><i>s</i></span> may make
the heap work incorrectly.<p></p>

</dd>
<dt><div class="d_decl">void <a name="assume"></a><span class="ddoc_psymbol">assume</span>(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</div></dt>
<dd>Takes ownership of a store assuming it already was organized as a
heap.<p></p>

</dd>
<dt><div class="d_decl"><a name="release"></a><span class="ddoc_psymbol">release</span>();
</div></dt>
<dd>Clears the heap. Returns the portion of the store from <span class="d_inlinecode">0</span> up to
<span class="d_inlinecode">length</span>, which satisfies the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&ie=UTF-8&oe=UTF-8&q=heap property">heap property</a>.<p></p>

</dd>
<dt><div class="d_decl">bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if the heap is empty, <span class="d_inlinecode"><b>false</b></span> otherwise.<p></p>

</dd>
<dt><div class="d_decl">BinaryHeap <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</div></dt>
<dd>Returns a duplicate of the heap. The underlying store must also
support a <span class="d_inlinecode"><a name="dup"></a><span class="ddoc_psymbol">dup</span></span> method.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</div></dt>
<dd>Returns the length of the heap.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</div></dt>
<dd>Returns the capacity of the heap, which is the length of the
underlying store (if the store is a range) or the capacity of the
underlying store (if the store is a container).<p></p>

</dd>
<dt><div class="d_decl">ElementType!(Store) <a name="front"></a><span class="ddoc_psymbol">front</span>();
</div></dt>
<dd>Returns a copy of the front of the heap, which is the largest element
according to <span class="d_inlinecode">less</span>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</div></dt>
<dd>Clears the heap by detaching it from the underlying store.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="insert"></a><span class="ddoc_psymbol">insert</span>(ElementType!(Store) <i>value</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode"><i>value</i></span> into the store. If the underlying store is a range
and <span class="d_inlinecode">length == capacity</span>, throws an exception.<p></p>

</dd>
<dt><div class="d_decl">void <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>();
</div></dt>
<dd>Removes the largest element from the heap.<p></p>

</dd>
<dt><div class="d_decl">ElementType!(Store) <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
</div></dt>
<dd>Removes the largest element from the heap and returns a copy of
it. The element still resides in the heap's store. For performance
reasons you may want to use <span class="d_inlinecode">removeFront</span> with heaps of objects
that are expensive to copy.<p></p>

</dd>
<dt><div class="d_decl">void <a name="replaceFront"></a><span class="ddoc_psymbol">replaceFront</span>(ElementType!(Store) <i>value</i>);
</div></dt>
<dd>Replaces the largest element in the store with <span class="d_inlinecode"><i>value</i></span>.<p></p>

</dd>
<dt><div class="d_decl">bool <a name="conditionalInsert"></a><span class="ddoc_psymbol">conditionalInsert</span>(ElementType!(Store) <i>value</i>);
</div></dt>
<dd>If the heap has room to grow, inserts <span class="d_inlinecode"><i>value</i></span> into the store and
returns <span class="d_inlinecode"><b>true</b></span>. Otherwise, if <span class="d_inlinecode">less(<i>value</i>, front)</span>, calls <span class="d_inlinecode">replaceFront(<i>value</i>)</span> and returns again <span class="d_inlinecode"><b>true</b></span>. Otherwise, leaves
the heap unaffected and returns <span class="d_inlinecode"><b>false</b></span>. This method is useful in
scenarios where the smallest <span class="d_inlinecode">k</span> elements of a set of candidates
must be collected.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">BinaryHeap!(Store) <a name="heapify"></a><span class="ddoc_psymbol">heapify</span>(Store)(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</div></dt>
<dd>Convenience function that returns a <span class="d_inlinecode">BinaryHeap!Store</span> object
initialized with <span class="d_inlinecode">s</span> and <span class="d_inlinecode">initialSize</span>.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Array"></a><span class="ddoc_psymbol">Array</span>(T) if (is(T == bool));
</div></dt>
<dd>Array specialized for <span class="d_inlinecode">bool</span>. Packs together values efficiently by
allocating one bit per element.<p></p>

<dl><dt><div class="d_decl">struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</div></dt>
<dd>Defines the container's primary range.<p></p>

<dl><dt><div class="d_decl">Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br>T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br>void <a name="front"></a><span class="ddoc_psymbol">front</span>(bool <i>value</i>);
<br>T <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
<br>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br>T <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br>T <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
<br>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br>T <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
<br>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(T <i>value</i>, size_t <i>i</i>);
<br>T <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>i</i>);
<br>const ulong <a name="length"></a><span class="ddoc_psymbol">length</span>();
</div></dt>
<dd>Range primitives<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</div></dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has
       no elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Array!(bool) <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</div></dt>
<dd>Returns a duplicate of the container. The elements themselves
       are not transitively duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">ulong <a name="length"></a><span class="ddoc_psymbol">length</span>();
</div></dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">ulong <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</div></dt>
<dd>Returns the maximum number of elements the container can store
       without (a) allocating memory, (b) invalidating iterators upon
       insertion.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="reserve"></a><span class="ddoc_psymbol">reserve</span>(ulong <i>e</i>);
</div></dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">n</span> elements.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= n</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(<i>e</i> - capacity)</span><b><i>)</i></b> if <span class="d_inlinecode"><i>e</i> &gt; capacity</span>,
       otherwise <b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</div></dt>
<dd>Returns a range that iterates over all elements of the
       container, in a container-defined order. The container should
       choose the most convenient and fast method of iteration for <span class="d_inlinecode">      <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>()</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(ulong <i>a</i>, ulong <i>b</i>);
</div></dt>
<dd>Returns <i>a</i> range that iterates the container between two
       specified positions.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">bool <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br>void <a name="front"></a><span class="ddoc_psymbol">front</span>(bool <i>value</i>);
<br>bool <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br>void <a name="back"></a><span class="ddoc_psymbol">back</span>(bool <i>value</i>);
</div></dt>
<dd>Equivalent to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span> and <span class="d_inlinecode">opSlice().back</span>,
       respectively.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">bool <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(ulong <i>i</i>);
<br>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(bool <i>value</i>, ulong <i>i</i>);
<br>template <a name="opIndexOpAssign"></a><span class="ddoc_psymbol">opIndexOpAssign</span>(string op)<br>T <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(ulong <i>i</i>);
</div></dt>
<dd>Indexing operators yield or modify the value at a specified index.<p></p>

</dd>
<dt><div class="d_decl">template <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op,Stuff) if (op == "~")</div></dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span>
       and its argument.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements
       in <span class="d_inlinecode">stuff</span><p></p>

<dl><dt><div class="d_decl">Array!(bool) <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(Stuff <i>rhs</i>);
</div></dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span>
       and its argument.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements
       in <span class="d_inlinecode">stuff</span><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">template <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op,Stuff) if (op == "~")</div></dt>
<dd>Forwards to <span class="d_inlinecode">insertAfter(this[], stuff)</span>.<p></p>

<dl><dt><div class="d_decl">Array!(bool) <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Forwards to <span class="d_inlinecode">insertAfter(this[], <i>stuff</i>)</span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</div></dt>
<dd>Removes all contents from the container. The container decides
       how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="length"></a><span class="ddoc_psymbol">length</span>(ulong <i>newLength</i>);
</div></dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">      newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span></span>, the
       added elements are added to the container and initialized with
       <span class="d_inlinecode">ElementType.init</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b><i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">length == <i>newLength</i></span><p></p>

</dd>
<dt><div class="d_decl">alias <a name="insert"></a><span class="ddoc_psymbol">insert</span>;
<br>alias <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> in the container. <span class="d_inlinecode">stuff</span> can be a value
       convertible to <span class="d_inlinecode">ElementType</span> or a range of objects
       convertible to <span class="d_inlinecode">ElementType</span>.
<p></p>
The <span class="d_inlinecode">stable</span> version guarantees that ranges iterating over
       the container are never invalidated. Client code that counts on
       non-invalidating insertion should use <span class="d_inlinecode">stableInsert</span>.

<p></p>
<b>Returns:</b><br>The number of elements added.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
       elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt><div class="d_decl">alias <a name="linearInsert"></a><span class="ddoc_psymbol">linearInsert</span>;
<br>alias <a name="stableLinearInsert"></a><span class="ddoc_psymbol">stableLinearInsert</span>;
</div></dt>
<dd>Same as <span class="d_inlinecode">insert(stuff)</span> and <span class="d_inlinecode">stableInsert(stuff)</span>
       respectively, but relax the complexity constraint to linear.<p></p>

</dd>
<dt><div class="d_decl">T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span>;
</div></dt>
<dd>Picks one value in the container, removes it from the
       container, and returns it. The stable version behaves the same,
       but guarantees that ranges iterating over the container are
       never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">template <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff) if (is(Stuff : bool))<br>template <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff) if (isInputRange!(Stuff) &amp;&amp; is(ElementType!(Stuff) : bool))<br>alias <a name="stableInsertBack"></a><span class="ddoc_psymbol">stableInsertBack</span>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the back of the container. <span class="d_inlinecode">stuff</span> can
       be a value convertible to <span class="d_inlinecode">ElementType</span> or a range of
       objects convertible to <span class="d_inlinecode">ElementType</span>. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

<dl><dt><div class="d_decl">ulong <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the back of the container. <span class="d_inlinecode"><i>stuff</i></span> can
       be a value convertible to <span class="d_inlinecode">ElementType</span> or a range of
       objects convertible to <span class="d_inlinecode">ElementType</span>. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
<br>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span>;
</div></dt>
<dd>Removes the value at the front or back of the container. The
       stable version behaves the same, but guarantees that ranges
       iterating over the container are never invalidated. The
       optional parameter <span class="d_inlinecode">howMany</span> instructs removal of that many
       elements. If <span class="d_inlinecode">howMany &gt; n</span>, all elements are removed and no
       exception is thrown.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">ulong <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>(ulong <i>howMany</i>);
</div></dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
       container. Unlike the unparameterized versions above, these
       functions do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span>
       elements. Instead, if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are
       removed. The returned value is the effective number of elements
       removed. The stable version behaves the same, but guarantees
       that ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b><i>)</i></b>.
     
 ditto<p></p>

</dd>
<dt><div class="d_decl">template <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)<br>alias <a name="stableInsertBefore"></a><span class="ddoc_psymbol">stableInsertBefore</span>;
<br>template <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)<br>alias <a name="stableInsertAfter"></a><span class="ddoc_psymbol">stableInsertAfter</span>;
<br>template <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff) if (is(Stuff : bool))<br>alias <a name="stableReplace"></a><span class="ddoc_psymbol">stableReplace</span>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>,
       which must be a valid range previously extracted from this
       container. <span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">      ElementType</span> or a range of objects convertible to <span class="d_inlinecode">      ElementType</span>. The stable version behaves the same, but
       guarantees that ranges iterating over the container are never
       invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

<dl><dt><div class="d_decl">ulong <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Range <i>r</i>, Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode"><i>stuff</i></span> before, after, or instead range <span class="d_inlinecode"><i>r</i></span>,
       which must be a valid range previously extracted from this
       container. <span class="d_inlinecode"><i>stuff</i></span> can be a value convertible to <span class="d_inlinecode">      ElementType</span> or a range of objects convertible to <span class="d_inlinecode">      ElementType</span>. The stable version behaves the same, but
       guarantees that ranges iterating over the container are never
       invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode"><i>stuff</i></span><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
<br>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span>;
</div></dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
       obtained originally from this container. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
       initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="RedBlackTree"></a><span class="ddoc_psymbol">RedBlackTree</span>(T,alias less = "a &lt; b",bool allowDuplicates = false) if (is(typeof(less(T.init,T.init)) == bool) || is(typeof(less) == string));
</div></dt>
<dd>Implementation of a <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&ie=UTF-8&oe=UTF-8&q=red-black tree">red-black tree</a> container.
<p></p>
All inserts, removes, searches, and any function in general has complexity
 of <b><i>&Omicron;</i>(</b><span class="d_inlinecode">lg(n)</span><b><i>)</i></b>.
<p></p>

 To use a different comparison than <span class="d_inlinecode">"a &lt; b"</span>, pass a different operator string
 that can be used by <a href="std_functional.html#binaryFun"><span class="d_inlinecode">std.functional.binaryFun</span></a>, or pass in a
 function, delegate, functor, or any type where <span class="d_inlinecode">less(a, b)</span> results in a <span class="d_inlinecode">bool</span>
 value.
<p></p>

 Note that less should produce a strict ordering.  That is, for two unequal
 elements <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>, <span class="d_inlinecode">less(a, b) == !less(b, a)</span>. <span class="d_inlinecode">less(a, a)</span> should
 always equal <span class="d_inlinecode"><b>false</b></span>.
<p></p>

 If <span class="d_inlinecode">allowDuplicates</span> is set to <span class="d_inlinecode"><b>true</b></span>, then inserting the same element more than
 once continues to add more elements.  If it is <span class="d_inlinecode"><b>false</b></span>, duplicate elements are
 ignored on insertion.  If duplicates are allowed, then new elements are
 inserted after all existing duplicate elements.<p></p>

<dl><dt><div class="d_decl">alias <a name="Elem"></a><span class="ddoc_psymbol">Elem</span>;
</div></dt>
<dd>Element type for the tree<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</div></dt>
<dd>The range type for <span class="d_inlinecode">RedBlackTree</span><p></p>

<dl><dt><div class="d_decl">const bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if the range is empty<p></p>

</dd>
<dt><div class="d_decl">Elem <a name="front"></a><span class="ddoc_psymbol">front</span>();
</div></dt>
<dd>Returns the first element in the range<p></p>

</dd>
<dt><div class="d_decl">Elem <a name="back"></a><span class="ddoc_psymbol">back</span>();
</div></dt>
<dd>Returns the last element in the range<p></p>

</dd>
<dt><div class="d_decl">void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</div></dt>
<dd>pop the front element from the range
<p></p>
<b>complexity:</b><br>
amortized <b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</div></dt>
<dd>pop the back element from the range
<p></p>
<b>complexity:</b><br>
amortized <b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
</div></dt>
<dd>Trivial save implementation, needed for <span class="d_inlinecode">isForwardRange</span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</div></dt>
<dd>Check if any elements exist in the container.  Returns <span class="d_inlinecode"><b>true</b></span> if at least
 one element exists.<p></p>

</dd>
<dt><div class="d_decl">RedBlackTree <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</div></dt>
<dd>Duplicate this container.  The resulting container contains a shallow
 copy of the elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</div></dt>
<dd>Fetch a range that spans all the elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Elem <a name="front"></a><span class="ddoc_psymbol">front</span>();
</div></dt>
<dd>The <a name="front"></a><span class="ddoc_psymbol">front</span> element in the container
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Elem <a name="back"></a><span class="ddoc_psymbol">back</span>();
</div></dt>
<dd>The last element in the container
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">template <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op) if (op == "in")</div></dt>
<dd>Check to see if an element exists in the container
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

<dl><dt><div class="d_decl">bool <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(Elem <i>e</i>);
</div></dt>
<dd>Check to see if an element exists in the container
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</div></dt>
<dd>Clear the container of all elements
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">template <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>(Stuff) if (isImplicitlyConvertible!(Stuff,Elem))</div></dt>
<dd>Insert a single element in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

<dl><dt><div class="d_decl">size_t <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Insert a single element in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">template <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>(Stuff) if (isInputRange!(Stuff) &amp;&amp; isImplicitlyConvertible!(ElementType!(Stuff),Elem))<br>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span>;
</div></dt>
<dd>Insert a range of elements in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b><p></p>

<dl><dt><div class="d_decl">size_t <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span>(Stuff <i>stuff</i>);
</div></dt>
<dd>Insert a range of elements in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">Elem <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
</div></dt>
<dd>Remove an element from the container and return its value.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="removeFront"></a><span class="ddoc_psymbol">removeFront</span>();
</div></dt>
<dd>Remove the front element from the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
</div></dt>
<dd>Remove the back element from the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(Range <i>r</i>);
</div></dt>
<dd>Remove the given range from the container.  Returns a range containing
 all the elements that were after the given range.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="upperBound"></a><span class="ddoc_psymbol">upperBound</span>(Elem <i>e</i>);
</div></dt>
<dd>Get a range from the container with all elements that are &gt; <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="lowerBound"></a><span class="ddoc_psymbol">lowerBound</span>(Elem <i>e</i>);
</div></dt>
<dd>Get a range from the container with all elements that are &lt; <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="equalRange"></a><span class="ddoc_psymbol">equalRange</span>(Elem <i>e</i>);
</div></dt>
<dd>Get a range from the container with all elements that are == <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="printTree"></a><span class="ddoc_psymbol">printTree</span>(Node <i>n</i>, int <i>indent</i> = 0);
</div></dt>
<dd>Print the tree.  This prints a sideways view of the tree in ASCII form,
 with the number of indentations representing the level of the nodes.
 It does not print values, only the tree structure and color of nodes.<p></p>

</dd>
<dt><div class="d_decl">void <a name="check"></a><span class="ddoc_psymbol">check</span>();
</div></dt>
<dd>Check the tree for validity.  This is called after every add or remove.
 This should only be enabled to debug the implementation of the RB Tree.<p></p>

</dd>
<dt><div class="d_decl">template <a name="__ctor"></a><span class="ddoc_psymbol">__ctor</span>(U) if (isImplicitlyConvertible!(U,Elem))</div></dt>
<dd>Constructor.  Pass in an array of elements, or individual elements to
 initialize the tree with.<p></p>

</dd>
<dt><div class="d_decl">template <a name="__ctor"></a><span class="ddoc_psymbol">__ctor</span>(Stuff) if (isInputRange!(Stuff) &amp;&amp; isImplicitlyConvertible!(ElementType!(Stuff),Elem) &amp;&amp; !is(Stuff == Elem[]))</div></dt>
<dd>Constructor.  Pass in a range of elements to initialize the tree with.<p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>


<div id="copyright">
Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code
copyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.

 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
